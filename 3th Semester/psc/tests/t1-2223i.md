# 1
```
Implemente em linguagem C, a função next_power_of_2 que determina a menor 
potência de 2, maior ou igual a value.
```

```c
// potência de 2 -> todos os valores são 0, exceto 1
unsigned next_power_of_2(unsigned value) {
    unsigned power = 1;
    while (power < value) {
        power = power << 1;
    }
    return power;
}
```

# 2
```
Escreva a função get_basename, que identifica num caminho (pathname) o nome de 
base de um ficheiro (basename). 

Exemplo 1: pathname: /home/ezequiel/main.c; basename: main; 

exemplo 2: pathname: a.out; basename: a; 

exemplo 3: /home/aluno/serie3/makefile; basename: makefile. 

A função devolve como valor, o ponteiro para o primeiro carácter de basename e 
devolve através do ponteiro basename_size o número de caracteres de basename.
```

```c
// Não está a remover os chars após o "."

char *get_basename(const char *pathname, size_t *basename_size) {
    const char *last_slash = NULL;

    // Percorrer o pathname para encontrar a última "/"
    for (const char *ptr = pathname; *ptr != '\0'; ++ptr) {
        if (*ptr == '/')
            last_slash = ptr;
    }

    *basename_size = (size_t)(last_slash ? strlen(last_slash + 1) : strlen(pathname) );

    // Se existir "/" buscar o char a seguir
    char *basename = (char *)(last_slash ? last_slash + 1 : pathname);

    return basename;
}
```

# 3
```
Implemente em assembly x86-64 a função get_far_south, cuja definição em 
linguagem C se apresenta abaixo.
```

```c
typedef struct { 
    int latitude, // 4 bytes
    int longitude; // 4 bytes
} Place; // 8 bytes

typedef struct { 
    int tag; // 4 bytes
    size_t length; // 4 bytes
    Place *places[]; // 8 bytes
} Route; // 16 bytes

int get_far_south(Route *routes, size_t n_routes, int tag, int *far_south) {
    for (size_t i = 0; i < n_routes; ++i)
        if (routes[i].tag == tag) {
            Route *route = &routes[i];
            long south = route->places[0]->latitude;
            for (size_t j = 1; j < route->length; j++)
                if (south > route->places[j]->latitude)
                    south = route->places[j]->latitude;
            *far_south = south;
            return 1;
        }
    return 0;
}
```

```s
get_far_south:
    # rdi = Route *routes
    # rsi = size_t n_routes
    # rdx = int tag
    # rcx = int *far_south
    push    %rbx
    push    %r12
    push    %r13
    push    %r14
    push    %r15
    
for_1_init:
    # r12 = i
    mov     $0, %r12
    jmp     for_1_if
for_1_inc_i:
    inc     %r12
for_1_if:
    cmp     %r12, %rsi
    jle     return_0
for_1_if_1:
    mov     (%rdi, %r12, 0), %rax
    cmp     %rax, %rdx
    jne     for_1_inc_i
    # r13 = Route *route
    lea     (%rdi, %r12, 8), %rax
    mov     %rax, %r13
    # r14 = long south
    mov     $0, %rbx
    mov     (%r13, %rbx, 4), %r14

for_2_init:
    # r15 = j
    mov     $1, %r15
    jmp     for_2_if
for_2_inc_j:
    inc     $r15
for_2_if:    
    mov     4(%r13), %rax
    cmp     %r15, %rax
    jle     return_1
for_2_if_1:
    mov     (%r13, %r15, 4), %rax  
    cmp     %r14, %rax
    jg      for_2_inc_j
    mov     %rax, %r14
    jmp     for_2_inc_j

return_1:
    mov     %r14, (%rcx)
    mov     $1, %eax
    jmp     return

return_0:
    mov     $0, %eax

return:
    pop 	%r15
    pop 	%r14
    pop 	%r13
    pop 	%r12
    pop 	%rbx
    ret
```